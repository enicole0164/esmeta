\section{Introduction}\label{sec:intro}

In the beginning, JavaScript was a simple scripting language designed in a
ten-day hack. However, it has become a de facto Web standard and eventually
becomes one of the dominating programming languages in various fields. For
example, Node.js~\cite{nodejs} introduced full-stack JavaScript by supporting
server-side programming.  React Native~\cite{react-native} provides a way to
deploy JavaScript programs as mobile and desktop applications in different
platforms.  Furthermore, according to the annual report of GitHub, JavaScript
has consistently been the most popular programming language based on the number
of contributors to GitHub
projects.\footnote{\url{https://octoverse.github.com/}}

Many developers and researchers have presented diverse tools for a better
development environment for JavaScript. In industry, developers develop
commercial JavaScript engines, such as Google V8~\cite{v8} and Oracle
GraalJS~\cite{graaljs}, to execute JavaScript programs.  They continuously
improve performance of the engines using optimization techniques (e.g., JIT
compilation) and update them to support annually introduced new language
features of JavaScript.  Besides, JavaScript compilers are also actively
developed as well; Babel~\cite{babel} compiles ES6+ JavaScript code to ES5.1
code for legacy web browsers, and the TypeScript compiler compiles TypeScript
programs to JavaScript programs.  In academia, researchers have presented
diverse techniques to check and enhance the code quality for JavaScript,
such as static analysis~\cite{safe, safe2, tajs, wala, jsai},
verification~\cite{javert, javert2, ad-safety, javanni}, symbolic
execution~\cite{symbolic-js, sym-js, expo-se}, and concolic
testing~\cite{jalangi, type-conc-test}.

Therefore, they always desire to understand the detailed semantics of
JavaScript.  Common JavaScript programmers usually learn the language by reading
non-standard materials, such as MDN Web Docs~\cite{mdn-doc}, blog posts, or
Stack Overflow~\cite{stackoverflow}, because they explain high-level concepts of
language features more friendly with simple examples.  However, such informal
reading materials are not for developers or researchers who design the tools for
JavaScript.  Beyond high-level concepts, they desire to understand the detailed
semantics of each language feature, including special corner cases, interactions
with other language features, or implicit side effects.  For example, consider a
JavaScript logical nullish assignment \jscode{x ??= y} newly introduced in ES12.
It assigns \jscode{y} to \jscode{x} only if \jscode{x} is nullish
(\jscode{undefined} or \jscode{null}). Therefore, it seems to have exactly same
semantics with an assignment \jscode{x = x ?? y} with a nullish coalescing
operator \jscode{??}.  However, it is not true because of the short-circuiting
for assignments:
\begin{lstlisting}[style=JS]
       const x = 0;  x ??= 1;    // x === 0
       const y = 0;  y = y ?? 1; // TypeError
\end{lstlisting}
and the named evaluation for anonymous functions:
\begin{lstlisting}[style=JS]
   let f;  f ??= () => {};      // f.name === "f"
   let g;  g = g ?? (() => {}); // g.name === ""
\end{lstlisting}
Such misunderstanding of complex semantics in JavaScript causes the wrong
implementation of the tools for JavaScript.

To understand the detailed semantics of JavaScript, developers and researchers
refer to its standard language specification and conformance test suite.
ECMA-262~\cite{es12} is the standard specification defining ECMAScript, the
official name of JavaScript.  It describes syntax using a variant of the
extended Backusâ€“Naur form (EBNF) and its semantics as abstract algorithms in
English.  On the other hand, Test262~\cite{test262} is a conformance test suite,
and it consists of JavaScript programs containing assertions to check specific
syntax and semantics.  The Ecma Technical Committee 39 (TC39) has maintained
both as open-source GitHub projects.  The committee continuously updates them
with new language features to quickly adapt to users' demands.  Therefore,
developers and researchers strive to keep up with the recent version of ECMA-262
to support new language features correctly in their tools or techniques.

However, it is nontrivial to understand all the detailed semantics by reading
the specification or conformance tests even to language designers.  First, they
are massive because of the fast-evolving nature of JavaScript.  The latest
ECMA-262 (ES12, 2021) is 879 pages with \inred{2,640} algorithms, and Test262
contains 41,415 test programs.
% However, it is infeasible to know all the detailed complex semantics by
% reading the specification or test suite even to language designers.

% Thus, researchers have presented several tools for a better understanding of
% JavaScript semantics. For example, JSExplain~\cite{jsexplain} is a reference
% interpreter that provides step-by-step execution of a given JavaScript program
% by closely following the English sentences of the specification. Several
% JavaScript language designers accept the concept of reference interpreters and
% implement Narcissus~\cite{narcissus} and engine262~\cite{engine262} to use in
% the language design process. On the other hand, TC39 feels the need for type
% information in ECMAScript to enhance its readability and has started internal
% discussions on manual type annotations for each abstract
% algorithm\footnote{https://github.com/tc39/ecmarkup/issues/173}. To meet the
% demand of type information, \citet{jstar} presents a tool named $\jstar$ to
% perform a type analysis for a given ECMAScript. Besides, they detect
% type-related specification bugs in ES12 using the type analysis result. Finally,
% $\jest$~\cite{jest} is another tool that synthesizes JavaScript conformance
% tests from a given ECMAScript. Thus, it allows users to understand language
% semantics using test programs instead of English sentences in the specification.
% 
% However, existing tools have two limitations: 1) manual update for evolving
% language specification and 2) no user interactions to select target semantics.
% Among existing tools, JavaScript reference interpreters require manual updates
% when ECMAScript evolves. Until 2015, it was not a critical problem because
% ECMAScript had rarely evolved. However, TC39 decided to annually release the
% specification with a massive update in ECMAScript 6 (ES6, 2015)~\cite{es6} in
% 2015. Moreover, they published the specification as an open-source project in a
% GitHub repository to quickly adapt users' demands to the language. For example,
% JSExplain also requires manual updates for new specifications. Thus, it still
% supports only ECMAScript 5.1 (ES5.1, 2011)~\cite{es5}, while already seven more
% versions from ES6 to ES12 have been released. Another limitation is that
% existing tools do not support user interactions to select target semantics to
% get additional information. For example, $\jstar$ and $\jest$ do not interact
% with users to give more information helpful for semantics understanding.
% Instead, they only extract type information and conformance tests for a given
% ECMAScript. On the other hand, while JSExplain supports step-by-step execution
% as user interaction with several debugger-like features, it can deal with only
% the execution trace of a single JavaScript program.
% 
% In this paper, we present $\tool$, a \textbf{J}ava\textbf{S}cript
% \textbf{I}nteractive \textbf{S}pecification. It is the first reference
% interpreter automatically synchronized with a given ECMAScript supporting
% step-by-step program execution. Fortunately, \citet{jiset} presents a tool named
% $\jiset$ that extracts a mechanized specification from a given specification.
% The extracted mechanized specification is written in a specification language
% $\ires$ and executable with a JavaScript program. Thus, we implement our tool
% using $\jiset$ and design debugger-like features: stepping controls, state
% visualization, and breakpoints with algorithm names or JavaScript program
% points. Moreover, our tool supports two different types of user interactions to
% select target semantics: \textit{syntactic view selection} and \textit{algorithm
% step selection}. First, we introduce a way to reduce abstract algorithms using a
% partial evaluation~\cite{peval, peval-survey, trans-ai} with a \textit{syntactic
% view}. A syntactic view is a JavaScript Abstract Syntax Tree (AST) defined with
% abstracted nodes. We formally define a partial evaluation with syntactic views
% and prove its semantics preservation under the given syntactic view. Second, we
% also present a way to extract a small-sized program for each algorithm step
% using delta debugging~\cite{delta-debugging} with a given set of programs. For
% the f first step, we execute each program using $\tool$ to compute semantics
% coverage in ECMAScript and filter out unnecessary programs. Then, we perform
% delta debugging for each program to reduce program sizes without loss of
% semantics coverage.
% 
% Our contributions are as follows:
% \begin{itemize}
%   \item We present $\tool$, a JavaScript interactive specification. It is the
%     first reference interpreter automatically synchronized with a given
%     ECMAScript supporting \textit{step-by-step program execution} with various
%     debugger-like featuress.
% 
%   \item We introduce two different types of user interactions to select target
%     semantics and implement them in $\tool$: 1) a \textit{syntactic view
%     selection} to reduce abstract algorithms using \textit{partial evaluation}
%     and 2) an \textit{algorithm step selection} to extract a small-sized
%     JavaScript program related to the selected step using \textit{delta
%     debugging} with a given set of programs.
% 
%   \item We evaluate $\tool$ with the latest ECMAScript, ES12, and experimentally
%     show the effectiveness of two different target semantics selections with
%     \inred{177} syntactic views and \inred{19,839} programs. Our tool
%     successfully supports step-by-step program execution in ES12. It reduces
%     \inred{18.9}\% algorithm steps for each syntactic view and provides
%     \inred{2.3} lines (\inred{152.3} bytes) of a program for each step on
%     average.
% \end{itemize}
