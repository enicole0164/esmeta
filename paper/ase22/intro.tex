\section{Introduction}\label{sec:intro}

\begin{figure}
  \centering
  \includegraphics[width=\columnwidth]{img/add-eval-algo.png}
  \caption{The \esalg{Evaluation} algorithm of the addition operator
  ($\code{+}$) in ES12}
  \vspace*{-1em}
  \label{fig:add-eval-algo}
\end{figure}

In the beginning, JavaScript was a simple scripting language designed in a
ten-day hack. However, it has become a de facto Web standard and eventually
became one of the dominating programming languages in various fields. For
example, Node.js~\cite{nodejs} introduced full-stack JavaScript by supporting
server-side programming.  In addition, React Native~\cite{react-native} provides
a way to deploy JavaScript programs as mobile and desktop applications even
running on different platforms.  Furthermore, according to the annual report of
GitHub, JavaScript has consistently been the most popular programming language
based on the number of contributors to GitHub
projects.\footnote{\url{https://octoverse.github.com/}}

However, despite its popularity, developers and even JavaScript experts often
suffer from its highly dynamic and complex nature.  It supports diverse language
features having complicated semantics, including higher-order functions, mutable
prototypes chain, dynamic code generation, and asynchronous functions.  For
instance, semantic of the addition operator is also not simple. It is not
commutative, and even its result type might be dependent on the order of the
operands as follows:
\begin{center}
  \begin{tabular}{c}
    \begin{lstlisting}[style=JS]
{} + "" // 0
"" + {} // "[object Object]"
    \end{lstlisting}
  \end{tabular}
\end{center}
The result of the addition between an empty object $\;\jscode{\{\}}$ and an empty
string $\jscode{""}$ is a number $\jscode{0}$, but it becomes a string
$\jscode{"[object Object]"}$ with the reversed order of operands.  It happens
because the addition operator has complex rules for implicit type conversions
while it simply represents numeric additions or string concatenation in most
other languages.  Such a complex language feature causes pain even to JavaScript
experts in understanding the language semantics.  For example, while V8 is the
most widely-used JavaScript engine developed by Google for Node.js and Chrome
web browsers, its semantic bugs have consistently been reported to its issue
tracker.\footnote{\url{https://bugs.chromium.org/p/v8}}

Therefore, when they desire to understand the detailed semantics of JavaScript,
they refer to \textit{ECMA-262}.  It is the standard specification written in
English defining ECMAScript, which is the official name of JavaScript.  It
describes the syntax via a variant of the extended Backusâ€“Naur form and the
semantics via abstract algorithms consisting of structured steps.

For example, Figure~\ref{fig:add-eval-algo} shows the \esalg{Evaluation}
algorithm of the addition operator in the latest ECMA-262 (ES12,
2021)~\cite{es12}.
\footnote{\url{https://262.ecma-international.org/12.0/\#sec-addition-operator-plus}}
It consists of a single step that invokes another algorithm,
\esalg{EvaluateStringOrNumericBinaryExpression}; the first and third arguments
are the left and right subtrees of the abstract syntax tree (AST) for a given
additive expression, and the second one is a text \code{+} to represent the
additive operation.  The \esalg{EvaluateStringOrNumericBinaryExpression} is a
generic algorithm for string or numeric binary operations (e.g., \code{-},
\code{*}, \code{<}, etc.).

Unfortunately, it is still challenging to 1) understand all the \textit{possible
behaviors} of language features and 2) find concrete \textit{example programs}
that trigger such behaviors by only referring to the language specification.
First, it is not an easy task to answer which behaviors are possible in each
language feature.  It often provides hidden implicit behaviors unusual in other
languages, such as implicit function calls, implicit property reads/writes, or
runtime exceptions under special conditions.  Besides, the problem becomes more
complicated if we want to know possible behaviors of a language feature used
with specific types of values or other language features.  Second, even if users
realize its specific behavior, it is nontrivial to find example programs that
trigger the behavior.

For instance, Assume that we realize that the addition operator might cause
implicit function calls.  Then, we should make an additional effort to grasp
when it is triggered if we want to find the following example programs:
\begin{center}
  \begin{tabular}{c}
    \begin{lstlisting}[style=JS]
var x = { toString: () => "a" };
x + "b"; // "ab" with an implicit call of `x.toString()`
    \end{lstlisting}
  \end{tabular}
\end{center}
In this code, the left and right operands have different types \code{Object} and
\code{String}, respectively.  It causes an implicit conversion from the object
in the variable \code{x} to a string value with an implicit call of the user
function in \code{x.toString}.

To alleviate this problem, we present $\tool$, which 1) automatically infers
possible behaviors of JavaScript language features from ECMA-262 and 2) finds
corresponding example programs in Test262~\cite{test262}, an official JavaScript
conformance test suite.

We first introduce a \textit{syntactic view}, an extension of a JavaScript
abstract syntax tree (AST) consisting of both concrete and abstract nodes with
optional type bounds.  Users can freely construct syntactic views depending on
which semantics they want to understand; concrete nodes denote the language
features they want to understand, and abstract ones denote the parts they do
not.

Then, our tool performs reachability analysis to soundly reduce the call graph
of ECMA-262 with a given syntactic view to infer possible behaviors.  Our key
observation is that the reachability of specific algorithms in the language
specification implies possible behaviors of language features.  For example, the
\esalg{Call} algorithm in ECMA-262 represents function calls.  Thus, if the
reduced call graph of ECMA-262 with a syntactic view for the addition operator
contains the \esalg{Call} algorithm, the addition operator might cause implicit
function calls.

In addition, $\tool$ searches concrete example programs in Test262 that trigger
such behaviors.  Our tool collects execution traces of all Test262 programs in a
database only once at initialization time and utilizes the database to quickly
search programs with a given syntactic view and a selected algorithm.

We evaluate the effectiveness of $\tool$ with the latest ECMA-262 (ES12, 2021)
and demonstrate its practicality with \inred{three} advanced syntactic views.

Our contributions are as follows:
\begin{itemize}
  \item We introduce a \textit{syntactic view}, an extension of a JavaScript
    abstract syntax tree (AST) consisting of both concrete and abstract nodes
    with optional type bounds, to help users indicate which language features
    they want to understand.

  \item We present an automatic way to 1) infer \textit{possible behaviors} of
    JavaScript language features using a reachability analysis in ECMA-262 from
    a given syntactic view and 2) search concrete \textit{example programs} in
    Test262 that trigger such behaviors using their pre-collected execution
    traces on the specification.

  \item We actualize our techniques in $\tool$ and evaluate its effectiveness
    using the latest ECMA-262 with \inred{177} basic syntactic views and discuss
    its practicality with \inred{three} advanced syntactic views.
\end{itemize}
