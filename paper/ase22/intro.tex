\section{Introduction}\label{sec:intro}

In the beginning, JavaScript was a simple scripting language designed in a
ten-day hack. However, it has become a de facto Web standard and eventually
became one of the dominating programming languages in various fields. For
example, Node.js~\cite{nodejs} introduced full-stack JavaScript by supporting
server-side programming.  React Native~\cite{react-native} provides a way to
deploy JavaScript programs as mobile and desktop applications even running on
different platforms.  Furthermore, according to the annual report of GitHub,
JavaScript has consistently been the most popular programming language based on
the number of contributors to GitHub
projects.\footnote{\url{https://octoverse.github.com/}}

Many developers and researchers have presented diverse tools for a better
development environment for JavaScript. In the industry, developers develop
commercial JavaScript engines, such as Google V8~\cite{v8} and Oracle
GraalJS~\cite{graaljs}, to execute JavaScript programs.  They continuously
improve the performance of the engines using optimization techniques (e.g., JIT
compilation) and update them to support newly introduced language features of
JavaScript.  Besides, JavaScript compilers are also actively developed as well;
Babel~\cite{babel} compiles ES6+ JavaScript code to ES5.1 code for legacy web
browsers, and the TypeScript compiler gives developers a chance to use a static
type system when developing JavaScript programs.  In the academia, researchers
have presented various techniques to check and enhance the code quality for
JavaScript, such as static analysis~\cite{safe, safe2, tajs, wala, jsai},
verification~\cite{javert, javert2, ad-safety, javanni}, symbolic
execution~\cite{symbolic-js, sym-js, expo-se}, and concolic
testing~\cite{jalangi, type-conc-test}.

Therefore, they carefully read its standard \textit{language specification} and
\textit{conformance test suite} to understand JavaScript semantics.  Ordinary
JavaScript programmers usually learn the language by referring to non-standard
materials, such as MDN Web Docs~\cite{mdn-doc}, blog posts, or Stack
Overflow~\cite{stackoverflow}.  They explain high-level concepts of language
features more friendly with simple examples.  However, such informal reading
materials are not enough for developers or researchers who design the tools for
JavaScript.  Beyond high-level concepts, they desire to understand the detailed
semantics of each language feature, including corner cases, interactions with
other language features, or implicit side effects. Thus, they read the language
specification, ECMA-262~\cite{es12}, and the conformance test suite,
Test262~\cite{test262}.  ECMA-262 is the standard specification defining
ECMAScript, the official name of JavaScript.  It describes syntax using a
variant of the extended Backusâ€“Naur form (EBNF) and its semantics as abstract
algorithms in English.  On the other hand, Test262~\cite{test262} is a
conformance test suite, and it consists of JavaScript programs containing
assertions to check specific language semantics.

However, reading the language specification and conformance tests is often
burdensome or prone to misunderstanding the semantics even to language
designers.  First, they became massive materials because of the fast-evolving
nature of JavaScript.  The Ecma Technical Committee 39 (TC39) has maintained
ECMA-262 and Test262.  Until 2015, JavaScript was a stable and rarely updated
programming language, but JavaScript's prevalency in diverse fields increased
the users' demands for new language features.  To adapt to their requests, TC39
decided to release the specification annually with heavy updates for the
ECMAScript 6 (ES6 or ES2015)~\cite{es6} in 2015.  Besides, they published the
specification and the test suite as open-source projects in GitHub repositories.
Therefore, developers and researchers strive to keep up with their recent
versions to support new language features correctly in their tools or
techniques.  However, The latest ECMA-262 (ES12 or ES2021) becomes \inred{879}
pages with \inred{2,640} algorithms, and Test262 contains \inred{41,415} test
programs because of the fast-evolving nature of JavaScript.  In this setting, it
is troublesome to find which specification parts or test programs are related to
the semantics developers or researchers want to understand.

Another obstacle to understanding the JavaScript semantics is the lack of
connection between the specification and test suite.  Both ECAM-262 and Test262
complement each other even though they describe the same JavaScript semantics.
ECMA-262 explains how JavaScript works in detail using abstract algorithms
written in English, but it has a steep learning curve because of its intricated
structures with many jargons.  For example, we should learn numerous concepts
and terminologies to understand only the addition operator in ECMA-262:
completion records, references, environment records, implicit conversion helpers
(e.g., \esalg{ToPrimitive}, \esalg{ToString}), syntax-directed algorithms,
numeric method algorithms, or how mathematical values, Numbers, and BigInts
differ.  On the other hand, Test262 gives straightforward examples with
JavaScript programs and assertions, but it does not explain why each program
behaves like that.  Thus, it is helpful for readers to inform which parts of the
specification are related to which test programs.  Unfortunately, Test262,
however, provides only coarse relation to ECMA-262 using directory structures,
file names, and comments.  Furthermore, since TC39 manually maintains such
connections, the references to the specification are often wrong and even
deprecated when ECMA-262 is updated.

To alleviate this problem, we present an automatic way to reduce language
specification and test suite and connect each other.  We first introduce
\textit{syntactic views} to help users indicate which parts of JavaScript
semantics they want to understand.  A syntactic view is an extension of a
JavaScript abstract syntax tree (AST) consisting of both concrete and abstract
nodes.  Users can freely construct syntactic views depending on which semantics
they want to understand; concrete nodes denote the semantics they want to
understand, and abstract ones denote the parts they do not.  Using a given
syntactic view, we can reduce the language specification and test suite.  To
handle JavaScript syntax and semantics mechanically, we extract a JavaScript
definitional interpreter in an intermediate representation from ECMA-262.  Then,
we 1) reduce the specification using partial evaluation on the extracted
definitional interpreter and 2) filter out irrelevant test programs using their
execution traces on it.  Finally, we also present a way to connect each branch
in the reduced specification to related test programs.

To actualize our approach, we develop $\tool$, which stands for
\underline{J}avaScript \underline{Syn}tactic \underline{View}er.  It utilizes an
existing tool named $\jiset$~\cite{jiset} to extract a JavaScript definitional
interpreter from the language specification.  We evaluated our tool with the
latest ECMA-262 (ES12 or ES2021) and Test262.  First, we defined \inred{177}
basic syntactic views and showed how much it could reduce the specification and
conformance test suite for a given syntactic view. Then, we conducted
\inred{three} case studies with more advanced syntactic views.

Our contributions are as follows:
\begin{itemize}
  \item We introduce \textit{syntactic views} to help users indicate which parts
    of JavaScript semantics they want to understand.

  \item We present an automatic way to 1) reduce the language specification and
    conformance test suite for a given syntactic view and 2) connect each branch
    in the reduced specification to related test programs.

  \item We actualize our techniques by implementing $\tool$ and experimentally
    demonstrate its effectiveness with the latest language specification and
    conformance test suite.
\end{itemize}
