{
  "[YET] Let _realmRec_ be a new Realm Record.": "let realmRec = @REALM",
  "[YET] Set fields of _intrinsics_ with the values listed in <emu-xref href=\"#table-well-known-intrinsic-objects\"></emu-xref>. The field names are the names listed in column one of the table. The value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses <emu-xref href=\"#sec-global-object\"></emu-xref> through <emu-xref href=\"#sec-reflection\"></emu-xref>. All object property values are newly created object values. All values that are built-in function objects are created by performing CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_) where _steps_ is the definition of that function provided by this specification, _name_ is the initial value of the function's `name` property, _length_ is the initial value of the function's `length` property, _slots_ is a list of the names, if any, of the function's specified internal slots, and _prototype_ is the specified value of the function's [[Prototype]] internal slot. The creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.": "{ intrinsics = @INTRINSICS realmRec.Intrinsics = @INTRINSICS }",
  "[YET] Assert: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.": "assert (! (= realm.Intrinsics[\"%ThrowTypeError%\"] absent))",
  "[YET] If _O_ does not have an own property with key _P_, return *undefined*.": "if (= O.SubMap[P] absent) return undefined else {}",
  "[YET] If the host requires use of an exotic object to serve as _realm_'s global object, let _global_ be such an object created in a host-defined manner. Otherwise, let _global_ be *undefined*, indicating that an ordinary object should be created as the global object.": "let global = undefined",
  "[YET] If the host requires that the `this` binding in _realm_'s global scope return an object other than the global object, let _thisValue_ be such an object created in a host-defined manner. Otherwise, let _thisValue_ be *undefined*, indicating that _realm_'s global `this` binding should be the global object.": "let thisValue = undefined",
  "[YET] If _additionalInternalSlotsList_ is present, append each of its elements to _internalSlotsList_.": "if (! (= additionalInternalSlotsList absent)) internalSlotsList = (list-concat internalSlotsList additionalInternalSlotsList) else {}",
  "[YET] Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.": "{ let obj = (new OrdinaryObject()) let idx = 0 loop[repeat] (< idx internalSlotsList.length) { obj[internalSlotsList[idx]] = undefined idx = (+ idx 1) } }",
  "[YET] Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"></emu-xref>.": "nop",
  "[YET] Assert: If the caller will not be overriding both _obj_'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then _internalSlotsList_ contains [[Prototype]].": "assert true",
  "[YET] Assert: If the caller will not be overriding all of _obj_'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then _internalSlotsList_ contains [[Extensible]].": "assert true",
  "[YET] For each property of the Global Object specified in clause <emu-xref href=\"#sec-global-object\"></emu-xref>, do\n  1. [YET] Let _name_ be the String value of the property name.\n  1. [YET] Let _desc_ be the fully populated data Property Descriptor for the property, containing the specified attributes for the property. For properties listed in <emu-xref href=\"#sec-function-properties-of-the-global-object\"></emu-xref>, <emu-xref href=\"#sec-constructor-properties-of-the-global-object\"></emu-xref>, or <emu-xref href=\"#sec-other-properties-of-the-global-object\"></emu-xref> the value of the [[Value]] attribute is the corresponding intrinsic object from _realmRec_.\n  1. Perform ? DefinePropertyOrThrow(_global_, _name_, _desc_).": "{ let keys = (keys @GLOBAL.SubMap) let idx = 0 loop[repeat] (< idx keys.length) { let name = keys[idx] global.SubMap[name] = @GLOBAL.SubMap[name] idx = (+ idx 1) } global.SubMap.globalThis = (new PropertyDescriptor(\"Value\" -> global, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> true)) }",
  "[YET] Create any host-defined global object properties on _globalObj_.": "nop",
  "[YET] If the execution context stack is empty, return *null*.": "if (= @EXECUTION_STACK.length 0) return null else {}",
  "[YET] Let _ec_ be the topmost execution context on the execution context stack whose ScriptOrModule component is not *null*.": "{ let ec = absent let idx = 0 loop[repeat] (&& (< idx @EXECUTION_STACK.length) (= ec absent)) { if (! (= @EXECUTION_STACK[idx].ScriptOrModule null) ) ec = @EXECUTION_STACK[idx] else {} idx = (+ idx 1) } }",
  "[YET] If no such execution context exists, return *null*. Otherwise, return _ec_'s ScriptOrModule.": "if (= ec absent) return null else return ec.ScriptOrModule",
  "[YET] If _envRec_ has a binding for the name that is the value of _N_, return *true*.": "if (! (= envRec.SubMap[N] absent)) return true else {}",
  "[YET] Assert: The execution context stack is not empty.": "assert (! (= @EXECUTION_STACK.length 0))",
  "[YET] Resume the context that is now on the top of the execution context stack as the running execution context.": "nop",
  "[YET] Let _X_ be _O_'s own property whose key is _P_.": "let X = O.SubMap[P]",
  "[YET] If _Desc_ does not have any fields, return *true*.": "{ let descKeys = (keys Desc) if (= descKeys.length 0) return true else {} }",
  "[YET] If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.": "if (|| (&& (= x true) (= y true)) (&& (= x false) (= y false))) return true else return false",
  "[YET] Assert: _envRec_ does not already have a binding for _N_.": "assert (= envRec.SubMap[N] absent)",
  "[YET] Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized. If _D_ is *true*, record that the newly created binding may be deleted by a subsequent DeleteBinding call.": "{ envRec.SubMap[N] = (new MutableBinding(\"initialized\" -> false))  if (= D true) envRec.SubMap[N].maybeDeleted = true else {} }",
  "[YET] Assert: _envRec_ has a binding for _N_.": "assert (! (= envRec.SubMap[N] absent))",
  "[YET] If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.": "if (! envRec.SubMap[N].initialized) return comp[~throw~/~empty~]((new OrdinaryObject(\"Prototype\" -> @EXECUTION_STACK[0].Realm.Intrinsics[\"%ReferenceError.prototype%\"], \"ErrorData\" -> undefined))) else {}",
  "[YET] Return the value currently bound to _N_ in _envRec_.": "return envRec.SubMap[N].BoundValue",
  "[YET] Insert _d_ as the first element of _functionsToInitialize_.": "push d > functionsToInitialize",
  "[YET] Assert: _F_ is an extensible object that does not have a *\"length\"* own property.": "assert (&& F.Extensible (= F.SubMap.length absent))",
  "[YET] Assert: _F_ is an extensible object that does not have a *\"name\"* own property.": "assert (&& F.Extensible (= F.SubMap.name absent))",
  "[YET] Assert: _F_ is an extensible object that does not have a *\"prototype\"* own property.": "assert (&& F.Extensible (= F.SubMap.prototype absent))",
  "[YET] If _callerContext_ is not already suspended, suspend _callerContext_.": "nop",
  "[YET] Assert: _calleeContext_ is now the running execution context.": "assert (= calleeContext @EXECUTION_STACK[0])",
  "[YET] Assert: The next step never returns an abrupt completion because _localEnv_.[[ThisBindingStatus]] is not ~initialized~.": "assert true",
  "[YET] Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.": "let instantiatedVarNames = (copy parameterBindings)",
  "[YET] Insert _fn_ as the first element of _functionNames_.": "push fn > functionNames",
  "[YET] Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.": "(pop < @EXECUTION_STACK)",
  "[YET] Perform any necessary implementation-defined initialization of _calleeContext_.": "nop",
  "[YET] Let _result_ be the Completion Record that is the result of evaluating _F_ in a manner that conforms to the specification of _F_. _thisArgument_ is the *this* value, _argumentsList_ provides the named parameters, and the NewTarget value is *undefined*.": "call result = F.Code(thisArgument, argumentsList, undefined)",
  "[YET] Assert: _generatorBody_ is an Abstract Closure with no parameters.": "assert (? generatorBody: AbstractClosure)",
  "[YET] Assert: _genContext_ is the execution context of a generator.": "assert (? genContext: ExecutionContext)",
  "[YET] If _genContext_ does not have a Generator component, return ~non-generator~.": "if (= genContext.Generator absent) return ~non-generator~ else {}",
  "[YET] Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.": "(pop < @EXECUTION_STACK)",
  "[YET] Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.": "assert true",
  "[YET] Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.": "nop",
  "[YET] Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.": "assert (= methodContext @EXECUTION_STACK[0])",
  "[YET] Assert: If _result_ is not an abrupt completion, then Type(_result_) is an ECMAScript language type.": "assert true",
  "[YET] Assert: _x_ and _y_ are finite and non-zero.": "assert true",
  "[YET] Assert: _opText_ is present in the table in step <emu-xref href=\"#step-applystringornumericbinaryoperator-operations-table\"></emu-xref>.": "assert true",
  "[YET] Assert: _x_ and _y_ are both finite.": "(&& (! (|| (= x +INF) (= x -INF))) (! (|| (= y +INF) (= y -INF))))",
  "[YET] Remove the own property with name _P_ from _O_.": "delete O.SubMap[P]",
  "[YET] Return a String according to <emu-xref href=\"#table-typeof-operator-results\"></emu-xref>.": "{ let t = (typeof val) if (= t @Undefined) return \"undefined\" else if (= t @Null) return \"object\" else if (= t @Boolean) return \"boolean\" else if (= t @Number) return \"number\" else if (= t @String) return \"string\" else if (= t @Symbol) return \"symbol\" else if (= t @BigInt) return \"bigint\" else if (= t @Object) if (= val.Call absent) return \"object\" else return \"function\" else assert false }",
  "[YET] If _x_ and _y_ are exactly the same sequence of code units (same length and same code units at corresponding indices), return *true*; otherwise, return *false*.": "if (= x y) return true else return false",
  "[YET] Return a new unique Symbol value whose [[Description]] value is _descString_.": "return (new 'descString)",
  "[YET] Let _int_ be the mathematical value whose sign is the sign of _number_ and whose magnitude is floor(abs(ℝ(_number_))).": "{ let int = (floor (abs ([math] number))) if (< number 0.0f) int = (* -1 int) else {} }",
  "[YET] Let _newLenDesc_ be a copy of _Desc_.": "let newLenDesc = (copy Desc)",
  "[YET] Assert: _Receiver_ does not currently have a property _P_.": "assert (= Receiver.SubMap[P] absent)",
  "[YET] Assert: _C_ is an instance of the production <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>.": "assert true",
  "[YET] Return the result of left shifting _lnum_ by _shiftCount_ bits. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.": "return ([number] (<< ([math] lnum) shiftCount))",
  "[YET] Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.": "return ([number] (>> ([math] lnum) shiftCount))",
  "[YET] Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The mathematical value of the result is exactly representable as a 32-bit unsigned bit string.": "return ([number] (>>> ([math] lnum) shiftCount))",
  "[YET] Assert: _intrinsicDefaultProto_ is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.": "assert true",
  "[YET] Return the String representation of this Number value using the radix specified by _radixMV_. Letters `a`-`z` are used for digits with values 10 through 35. The precise algorithm is implementation-defined, however the algorithm should be a generalization of that specified in <emu-xref href=\"#sec-numeric-types-number-tostring\"></emu-xref>.": "return ([str radixMV] x)",
  "[YET] Assert: _object_ is an ordinary, extensible object with no non-configurable properties.": "assert true",
  "[YET] Assert: _base_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.": "assert (! (|| (= base 0.0f) (= base -0.0f)))",
  "[YET] Assert: _exponent_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.": "assert (! (|| (= exponent 0.0f) (= exponent -0.0f)))",
  "[YET] Return an implementation-approximated Number value representing the result of raising ℝ(_base_) to the ℝ(_exponent_) power.": "return ([number] (** ([math] base) ([math] exponent)))",
  "[YET] Let _internalSlotsList_ be a List containing the names of all the internal slots that <emu-xref href=\"#sec-built-in-function-objects\"></emu-xref> requires for the built-in function object that is about to be created.": "let internalSlotsList = (new [\"Prototype\", \"Extensible\", \"Realm\", \"InitialName\"])",
  "[YET] Append to _internalSlotsList_ the elements of _additionalInternalSlotsList_.": "internalSlotsList = (list-concat internalSlotsList additionalInternalSlotsList)",
  "[YET] Let _func_ be a new built-in function object that, when called, performs the action described by _behaviour_ using the provided arguments as the values of the corresponding parameters specified by _behaviour_. The new function object has internal slots whose names are the elements of _internalSlotsList_, and an [[InitialName]] internal slot.": "{ let func = (new BuiltinFunctionObject()) func.Code = behaviour }",
  "[YET] Let _asyncContext_ be a copy of _runningContext_.": "let asyncContext = (copy runningContext)",
  "[YET] Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.": "assert true",
  "[YET] Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.": "(pop < @EXECUTION_STACK)",
  "[YET] Assert: _F_ has a [[Promise]] internal slot whose value is an Object.": "assert (&& (! (= F.Promise absent)) (? F.Promise: Object))",
  "[YET] Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.": "assert (&& (= runningContext @EXECUTION_STACK[0]) (! (= asyncContext @EXECUTION_STACK[0])))",
  "[YET] Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.": "assert (&& (= prevContext @EXECUTION_STACK[0]) (! (= asyncContext @EXECUTION_STACK[0])))",
  "[YET] Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.": "assert true",
  "[YET] Remove the first element from _queue_.": "(pop < queue)",
  "[YET] Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.": "assert (&& (= callerContext @EXECUTION_STACK[0]) (! (= genContext @EXECUTION_STACK[0])))",
  "[YET] Assert: _lhs_ binds a single name.": "assert true",
  "[YET] Append the pair (a two element List) consisting of _nextKey_ and _desc_ to the end of _descriptors_.": "push descriptors < (new [nextKey, desc])",
  "[YET] Assert: _obj_ is an extensible ordinary object with no own properties.": "assert true",
  "[YET] Return an Iterator object (<emu-xref href=\"#sec-iterator-interface\"></emu-xref>) whose `next` method iterates over all the String-valued keys of enumerable properties of _O_. The iterator object is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.": "{ call %0 = clo<CreateForInIterator>(O) return %0 }",
  "[YET] Assert: _O_ has all of the internal slots of a For-In Iterator Instance (<emu-xref href=\"#sec-properties-of-for-in-iterator-instances\"></emu-xref>).": "assert true",
  "[YET] Remove the first element from _remaining_.": "(pop < remaining)",
  "[YET] Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.": "assert (&& (? O: Object) (! (= O.SyncIteratorRecord absent)))",
  "[YET] If _N_ is an element of _varNames_, remove that element from the _varNames_.": "remove-elem varNames N",
  "[YET] Return the result of applying bitwise complement to _oldValue_. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.": "return (~ oldValue)",
  "[YET] Let _k_ be the smallest non-negative integer such that the code unit at index _k_ within _px_ is different from the code unit at index _k_ within _py_. (There must be such a _k_, for neither String is a prefix of the other.)": "{ let k = 0 loop[repeat] (= px[k] py[k]) k = (+ k 1) }",
  "[YET] Let _m_ be the integer that is the numeric value of the code unit at index _k_ within _px_.": "let m = ([math] px[k])",
  "[YET] Let _n_ be the integer that is the numeric value of the code unit at index _k_ within _py_.": "let n = ([math] py[k])",
  "[YET] Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].": "let args = argumentsList",
  "[YET] Let _args_ be the _argumentsList_ that was passed to this function by [[Call]] or [[Construct]].": "let args = argumentsList",
  "[YET] Assert: The execution context stack has at least two elements.": "assert (< 1 @EXECUTION_STACK.length)",
  "[YET] Assert: If _direct_ is *false*, then _strictCaller_ is also *false*.": "assert true",
  "[YET] If _runningContext_ is not already suspended, suspend _runningContext_.": "nop",
  "[YET] Assert: The following loop will terminate.": "assert true",
  "[YET] Assert: _status_ is not an abrupt completion because of validation preceding step <emu-xref href=\"#step-evaldeclarationinstantiation-post-validation\"></emu-xref>.": "assert true",
  "[YET] Return the BigInt value that represents the negation of ℝ(_x_).": "return ([bigint] (- ([math] x)))",
  "[YET] If _O_ is not *undefined*, create an own accessor property named _P_ of object _O_ whose [[Get]], [[Set]], [[Enumerable]], and [[Configurable]] attribute values are described by _Desc_. If the value of an attribute field of _Desc_ is absent, the attribute of the newly created property is set to its <emu-xref href=\"#table-default-attribute-values\">default value</emu-xref>.": "if (! (= O undefined)) { let ap = (new PropertyDescriptor()) if (= Desc.Get absent) ap.Get = undefined else ap.Get = Desc.Get if (= Desc.Set absent) ap.Set = undefined else ap.Set = Desc.Set if (= Desc.Enumerable absent) ap.Enumerable = false else ap.Enumerable = Desc.Enumerable if (= Desc.Configurable absent) ap.Configurable = false else ap.Configurable = Desc.Configurable O.SubMap[P] = ap } else {}",
  "[YET] If _O_ is not *undefined*, create an own data property named _P_ of object _O_ whose [[Value]], [[Writable]], [[Enumerable]], and [[Configurable]] attribute values are described by _Desc_. If the value of an attribute field of _Desc_ is absent, the attribute of the newly created property is set to its <emu-xref href=\"#table-default-attribute-values\">default value</emu-xref>.": "if (! (= O undefined)) { let dp = (new PropertyDescriptor()) if (= Desc.Value absent) dp.Value = undefined else dp.Value = Desc.Value if (= Desc.Writable absent) dp.Writable = false else dp.Writable = Desc.Writable if (= Desc.Enumerable absent) dp.Enumerable = false else dp.Enumerable = Desc.Enumerable if (= Desc.Configurable absent) dp.Configurable = false else dp.Configurable = Desc.Configurable O.SubMap[P] = dp } else {}",
  "[YET] If _O_ is not *undefined*, convert the property named _P_ of object _O_ from an accessor property to a data property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their <emu-xref href=\"#table-default-attribute-values\">default values</emu-xref>.": "if (! (= O undefined)) { let dp2 = (new PropertyDescriptor(\"Configurable\" -> O.SubMap[P].Configurable, \"Enumerable\" -> O.SubMap[P].Enumerable)) dp2.Value = undefined dp2.Writable = false O.SubMap[P] = dp2 } else {}",
  "[YET] If _O_ is not *undefined*, convert the property named _P_ of object _O_ from a data property to an accessor property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their <emu-xref href=\"#table-default-attribute-values\">default values</emu-xref>.": "if (! (= O undefined)) { let ap2 = (new PropertyDescriptor(\"Configurable\" -> O.SubMap[P].Configurable, \"Enumerable\" -> O.SubMap[P].Enumerable)) ap2.Get = undefined ap2.Set = undefined O.SubMap[P] = ap2 } else {}",
  "[YET] Assert: _internalSlotsList_ is a List of internal slot names.": "assert (? internalSlotsList: List)",
  "[YET] Let _objRec_ be a new object Environment Record containing _G_ as the binding object.": "let objRec = (new ObjectEnvironmentRecord(\"BindingObject\" -> G, \"withEnvironment\" -> false))",
  "[YET] Assert: _sourceText_ is an ECMAScript source text (see clause <emu-xref href=\"#sec-ecmascript-language-source-code\"></emu-xref>).": "assert (? sourceText: String)",
  "[YET] Let _globalObject_ be the binding object for _ObjRec_.": "let globalObject = ObjRec.BindingObject",
  "[YET] Let _bindings_ be the binding object for _envRec_.": "let bindings = envRec.BindingObject",
  "[YET] If every field in _Desc_ is absent, return *true*.": "{ let descKeys = (keys Desc) if (= descKeys.length 0) return true else {} }",
  "[YET] If _Desc_.[[Configurable]] is present and its value is *true*, return *false*.": "if (&& (! (= Desc.Configurable absent)) (= Desc.Configurable true)) return false else {}",
  "[YET] For each field of _Desc_ that is present, set the corresponding attribute of the property named _P_ of object _O_ to the value of the field.": "{ let descFields = (keys Desc) let idx = 0 loop[foreach] (< idx descFields.length) { let df = descFields[idx] O.SubMap[P][df] = Desc[df] idx = (+ idx 1) } }",
  "[YET] If the code matching the syntactic production that is being evaluated is contained in strict mode code, let _strict_ be *true*; else let _strict_ be *false*.": "let strict = true",
  "[YET] If the _withEnvironment_ flag of _envRec_ is *false*, return *true*.": "if (= envRec.withEnvironment false) return true else {}",
  "[YET] Assert: If _tailPosition_ is *true*, the above call will not return here, but instead evaluation will continue as if the following return has already occurred.": "assert true",
  "[YET] Assert: _input_ is an ECMAScript language value.": "assert true",
  "[YET] Assert: _arguments_ is either ~empty~ or an |Arguments|.": "assert (|| (= arguments ~empty~) (? arguments: Arguments))",
  "[YET] Assert: _intrinsicDefaultProto_ is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.": "assert (? intrinsicDefaultProto: String)",
  "[YET] Let _parameterBindings_ be a List whose elements are the elements of _parameterNames_, followed by *\"arguments\"*.": "let parameterBindings = (list-concat parameterNames (new [\"arguments\"]))",
  "[YET] Assert: _S_ is an Object that has a [[StringData]] internal slot.": "assert (&& (? S: Object) (! (= S.StringData absent)))",
  "[YET] Assert: _steps_ is either a set of algorithm steps or other definition of a function's behaviour provided in this specification.": "assert true",
  "[YET] Assert: _iterNextObj_ is an Object that implements the <i>IteratorResult</i> interface.": "assert (? iterNextObj: Object)",
  "[YET] Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(ℝ(_number_))).": "{ let int = (floor (abs ([math] number))) if (< number 0.0f) int = (* -1 int) else {} }",
  "[YET] Assert: _generator_ is an AsyncGenerator instance.": "assert (? generator: Object)",
  "[YET] Append each item in _nextNames_ to the end of _boundNames_.": "boundNames = (list-concat boundNames nextNames)",
  "[YET] Append each item in _nextNames_ to the end of _propertyNames_.": "propertyNames = (list-concat propertyNames nextNames)",
  "[YET] Let _func_ be a new built-in function object that when called performs the action described by _steps_. The new function object has internal slots whose names are the elements of _internalSlotsList_, and an [[InitialName]] internal slot.": "let func = (new BuiltinFunctionObject(\"Code\" -> steps))",
  "[YET] Assert: _F_ has a [[Capability]] internal slot whose value is a PromiseCapability Record.": "assert (&& (! (= F.Capability absent)) (? F.Capability : PromiseCapabilityRecord))",
  "[YET] Let _operation_ be the abstract operation associated with _opText_ in the following table:\n  <figure>\n    <table class=\"lightweight-table\">\n    <tbody>\n    <tr><th> _opText_       </th><th> _operation_             </th></tr>\n    <tr><td> `**`           </td><td> _T_::exponentiate       </td></tr>\n    <tr><td> `*`            </td><td> _T_::multiply           </td></tr>\n    <tr><td> `/`            </td><td> _T_::divide             </td></tr>\n    <tr><td> `%`            </td><td> _T_::remainder          </td></tr>\n    <tr><td> `+`            </td><td> _T_::add                </td></tr>\n    <tr><td> `-`            </td><td> _T_::subtract           </td></tr>\n    <tr><td> `<<`     </td><td> _T_::leftShift          </td></tr>\n    <tr><td> `>>`     </td><td> _T_::signedRightShift   </td></tr>\n    <tr><td> `>>>` </td><td> _T_::unsignedRightShift </td></tr>\n    <tr><td> `&`        </td><td> _T_::bitwiseAND         </td></tr>\n    <tr><td> `^`            </td><td> _T_::bitwiseXOR         </td></tr>\n    <tr><td> `|`            </td><td> _T_::bitwiseOR          </td></tr>\n    </tbody>\n    </table>\n  </figure>": "{ if (= opText \"**\") let operation = @PRIMITIVE[T].exponentiate else {} if (= opText \"*\") let operation = @PRIMITIVE[T].multiply else {} if (= opText \"/\") let operation = @PRIMITIVE[T].divide else {} if (= opText \"%\") let operation = @PRIMITIVE[T].remainder else {} if (= opText \"+\") let operation = @PRIMITIVE[T].add else {} if (= opText \"-\") let operation = @PRIMITIVE[T].subtract else {} if (= opText \"<<\") let operation = @PRIMITIVE[T].leftShift else {} if (= opText \">>\") let operation = @PRIMITIVE[T].signedRightShift else {} if (= opText \">>>\") let operation = @PRIMITIVE[T].unsignedRightShift else {} if (= opText \"&\") let operation = @PRIMITIVE[T].bitwiseAND else {} if (= opText \"^\") let operation = @PRIMITIVE[T].bitwiseXOR else {} if (= opText \"|\") let operation = @PRIMITIVE[T].bitwiseOR else {} }",
  "[YET] Let _opText_ be the sequence of Unicode code points associated with _assignmentOpText_ in the following table:\n  <figure>\n    <table class=\"lightweight-table\">\n    <tbody>\n    <tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>\n    <tr><td> `**=`              </td><td> `**`           </td></tr>\n    <tr><td> `*=`               </td><td> `*`            </td></tr>\n    <tr><td> `/=`               </td><td> `/`            </td></tr>\n    <tr><td> `%=`               </td><td> `%`            </td></tr>\n    <tr><td> `+=`               </td><td> `+`            </td></tr>\n    <tr><td> `-=`               </td><td> `-`            </td></tr>\n    <tr><td> `<<=`        </td><td> `<<`     </td></tr>\n    <tr><td> `>>=`        </td><td> `>>`     </td></tr>\n    <tr><td> `>>>=`    </td><td> `>>>` </td></tr>\n    <tr><td> `&=`           </td><td> `&`        </td></tr>\n    <tr><td> `^=`               </td><td> `^`            </td></tr>\n    <tr><td> `|=`               </td><td> `|`            </td></tr>\n    </tbody>\n    </table>\n  </figure>": "{ if (= assignmentOpText \"**=\") let opText = \"**\" else {} if (= assignmentOpText \"*=\") let opText = \"*\" else {} if (= assignmentOpText \"/=\") let opText = \"/\" else {} if (= assignmentOpText \"%=\") let opText = \"%\" else {} if (= assignmentOpText \"+=\") let opText = \"+\" else {} if (= assignmentOpText \"-=\") let opText = \"-\" else {} if (= assignmentOpText \"<<=\") let opText = \"<<\" else {} if (= assignmentOpText \">>=\") let opText = \">>\" else {} if (= assignmentOpText \">>>=\") let opText = \">>>\" else {} if (= assignmentOpText \"&=\") let opText = \"&\" else {} if (= assignmentOpText \"^=\") let opText = \"^\" else {} if (= assignmentOpText \"|=\") let opText = \"|\" else {} }",
  "[YET] Return an implementation-approximated value representing the result of raising ℝ(_base_) to the ℝ(_exponent_) power.": "return ([number] (** ([math] base) ([math] exponent)))",
  "[YET] If _q_ can be the string-concatenation of _p_ and some other String _r_, return *true*. Otherwise, return *false*.": "if (! (< q.length p.length)) return (= (substring q 0 p.length) p) else return false",
  "[YET] Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-bound-function-exotic-objects\"></emu-xref>, plus [[Prototype]] and [[Extensible]].": "let internalSlotsList = (new [\"BoundTargetFunction\", \"BoundThis\", \"BoundArguments\", \"Prototype\", \"Extensible\"])",
  "[YET] Let _args_ be a List whose elements are the elements of _boundArgs_, followed by the elements of _argumentsList_.": "let args = (list-concat boundArgs argumentsList)",
  "[YET] Let _next_ be the value of the first element of _queue_.": "let next = queue[0]",
  "[YET] Assert: _result_ is a normal completion with a value of *undefined*. The possible sources of completion values are Await or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncfunctionstart-return-undefined\"></emu-xref> above.": "(= result comp[~normal~/~empty~](undefined))",
  "[YET] Assert: _next_ is an AsyncGeneratorRequest record.": "assert true",
  "[YET] Assert: _elements_ is a List whose elements are all ECMAScript language values.": "assert (? elements: List)",
  "[YET] Assert: _excludedItems_ is a List of property keys.": "assert (? excludedItems: List)",
  "[YET] Let _prefix_ be the prefix associated with _kind_ in <emu-xref href=\"#table-dynamic-function-sourcetext-prefixes\"></emu-xref>.": "{ if (= kind ~normal~) let prefix = \"function\" else {} if (= kind ~generator~) let prefix = \"function*\" else {} if (= kind ~async~) let prefix = \"async function\" else {} if (= kind ~asyncGenerator~) let prefix = \"async function*\" else {} }",
  "[YET] Append _label_ as an element of _labelSet_.": "push labelSet < label"
}
