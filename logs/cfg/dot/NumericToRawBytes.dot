digraph {
  graph [fontname = "Consolas"]
  node [fontname = "Consolas"]
  edge [fontname = "Consolas"]
  subgraph cluster2480 {
    label = "def NumericToRawBytes(type: Unknown["TypedArrayElementType"], value: Number | BigInt, isLittleEndian: Boolean): Unknown["ListOfByteValues"]"
    style = rounded
    cluster2480_entry_name [shape=none, label=<<font color="black">Entry</font>>]
    cluster2480_entry_name -> cluster2480_entry [arrowhead=none, color="black", style=dashed]
    cluster2480_entry [shape=circle label=" " color="black" fillcolor="white" style=filled]
    cluster2480_entry -> node17422 [color="black"]
    cluster2480_exit_name [shape=none, label=<<font color="black">Exit</font>>]
    cluster2480_exit_name -> cluster2480_exit [arrowhead=none, color="black", style=dashed]
    cluster2480_exit [shape=circle label=" " color="black" fillcolor="white" style=filled]
    node17422_name [shape=none, label=<<font color="black">Branch[17422]</font>>]
    node17422_name -> node17422 [arrowhead=none, color="black", style=dashed]
    node17422 [shape=diamond, label=<<font color="black">(= type ~Float32~)</font>> color="black" fillcolor="white", style=filled]
    node17422 -> node17423 [label=<<font color="black">true</font>> color="black"]
    node17422 -> node17424 [label=<<font color="black">false</font>> color="black"]
    node17423_name [shape=none, label=<<font color="black">Block[17423]</font>>]
    node17423_name -> node17423 [arrowhead=none, color="black", style=dashed]
    node17423 [shape=box, label=<<font color="black">[0] (yet &quot;Let _rawBytes_ be a List whose elements are the 4 bytes that are the result of converting _value_ to IEEE 754-2019 binary32 format using roundTiesToEven mode. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.&quot;)<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node17423 -> node17432 [color="black"]
    node17424_name [shape=none, label=<<font color="black">Branch[17424]</font>>]
    node17424_name -> node17424 [arrowhead=none, color="black", style=dashed]
    node17424 [shape=diamond, label=<<font color="black">(= type ~Float64~)</font>> color="black" fillcolor="white", style=filled]
    node17424 -> node17425 [label=<<font color="black">true</font>> color="black"]
    node17424 -> node17426 [label=<<font color="black">false</font>> color="black"]
    node17432_name [shape=none, label=<<font color="black">Block[17432]</font>>]
    node17432_name -> node17432 [arrowhead=none, color="black", style=dashed]
    node17432 [shape=box, label=<<font color="black">[0] return rawBytes<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node17432 -> cluster2480_exit [color="black"]
    node17425_name [shape=none, label=<<font color="black">Block[17425]</font>>]
    node17425_name -> node17425 [arrowhead=none, color="black", style=dashed]
    node17425 [shape=box, label=<<font color="black">[0] (yet &quot;Let _rawBytes_ be a List whose elements are the 8 bytes that are the IEEE 754-2019 binary64 format encoding of _value_. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.&quot;)<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node17425 -> node17432 [color="black"]
    node17426_name [shape=none, label=<<font color="black">Block[17426]</font>>]
    node17426_name -> node17426 [arrowhead=none, color="black", style=dashed]
    node17426 [shape=box, label=<<font color="black">[0] (yet &quot;Let _n_ be the Element Size value specified in &lt;emu-xref href=\&quot;#table-the-typedarray-constructors\&quot;&gt;&lt;/emu-xref&gt; for Element Type _type_.&quot;)<BR ALIGN="LEFT"/>[1] (yet &quot;Let _convOp_ be the abstract operation named in the Conversion Operation column in &lt;emu-xref href=\&quot;#table-the-typedarray-constructors\&quot;&gt;&lt;/emu-xref&gt; for Element Type _type_.&quot;)<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node17426 -> node17427 [color="black"]
    node17427_name [shape=none, label=<<font color="black">Call[17427]</font>>]
    node17427_name -> node17427 [arrowhead=none, color="black", style=dashed]
    node17427 [shape=cds, label=<<font color="black">%0 = convOp(value)</font>> color="black" fillcolor="white", style=filled]
    node17427 -> node17428 [color="black"]
    node17428_name [shape=none, label=<<font color="black">Block[17428]</font>>]
    node17428_name -> node17428 [arrowhead=none, color="black", style=dashed]
    node17428 [shape=box, label=<<font color="black">[0] let intValue = ([math] %0)<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node17428 -> node17429 [color="black"]
    node17429_name [shape=none, label=<<font color="black">Branch[17429]</font>>]
    node17429_name -> node17429 [arrowhead=none, color="black", style=dashed]
    node17429 [shape=diamond, label=<<font color="black">(! (&lt; intValue 0))</font>> color="black" fillcolor="white", style=filled]
    node17429 -> node17430 [label=<<font color="black">true</font>> color="black"]
    node17429 -> node17431 [label=<<font color="black">false</font>> color="black"]
    node17430_name [shape=none, label=<<font color="black">Block[17430]</font>>]
    node17430_name -> node17430 [arrowhead=none, color="black", style=dashed]
    node17430 [shape=box, label=<<font color="black">[0] (yet &quot;Let _rawBytes_ be a List whose elements are the _n_-byte binary encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.&quot;)<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node17430 -> node17432 [color="black"]
    node17431_name [shape=none, label=<<font color="black">Block[17431]</font>>]
    node17431_name -> node17431 [arrowhead=none, color="black", style=dashed]
    node17431 [shape=box, label=<<font color="black">[0] (yet &quot;Let _rawBytes_ be a List whose elements are the _n_-byte binary two's complement encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.&quot;)<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node17431 -> node17432 [color="black"]
  }
}