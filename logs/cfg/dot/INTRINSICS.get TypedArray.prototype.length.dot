digraph {
  graph [fontname = "Consolas"]
  node [fontname = "Consolas"]
  edge [fontname = "Consolas"]
  subgraph cluster2405 {
    label = "def <BUILTIN>:INTRINSICS.get TypedArray.prototype.length(this: ESValue, argumentsList: List[ESValue], NewTarget: Object | Undefined): Unknown"
    style = rounded
    cluster2405_entry_name [shape=none, label=<<font color="black">Entry</font>>]
    cluster2405_entry_name -> cluster2405_entry [arrowhead=none, color="black", style=dashed]
    cluster2405_entry [shape=circle label=" " color="black" fillcolor="white" style=filled]
    cluster2405_entry -> node16331 [color="black"]
    cluster2405_exit_name [shape=none, label=<<font color="black">Exit</font>>]
    cluster2405_exit_name -> cluster2405_exit [arrowhead=none, color="black", style=dashed]
    cluster2405_exit [shape=circle label=" " color="black" fillcolor="white" style=filled]
    node16331_name [shape=none, label=<<font color="black">Block[16331]</font>>]
    node16331_name -> node16331 [arrowhead=none, color="black", style=dashed]
    node16331 [shape=box, label=<<font color="black">[0] let O = this<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node16331 -> node16332 [color="black"]
    node16332_name [shape=none, label=<<font color="black">Call[16332]</font>>]
    node16332_name -> node16332 [arrowhead=none, color="black", style=dashed]
    node16332 [shape=cds, label=<<font color="black">%0 = clo&lt;RequireInternalSlot&gt;(O, &quot;TypedArrayName&quot;)</font>> color="black" fillcolor="white", style=filled]
    node16332 -> node16333 [color="black"]
    node16333_name [shape=none, label=<<font color="black">Block[16333]</font>>]
    node16333_name -> node16333 [arrowhead=none, color="black", style=dashed]
    node16333 [shape=box, label=<<font color="black">[0] [? %0]<BR ALIGN="LEFT"/>[1] assert (yet &quot;_O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.&quot;)<BR ALIGN="LEFT"/>[2] let buffer = O.ViewedArrayBuffer<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node16333 -> node16334 [color="black"]
    node16334_name [shape=none, label=<<font color="black">Call[16334]</font>>]
    node16334_name -> node16334 [arrowhead=none, color="black", style=dashed]
    node16334 [shape=cds, label=<<font color="black">%1 = clo&lt;IsDetachedBuffer&gt;(buffer)</font>> color="black" fillcolor="white", style=filled]
    node16334 -> node16335 [color="black"]
    node16335_name [shape=none, label=<<font color="black">Branch[16335]</font>>]
    node16335_name -> node16335 [arrowhead=none, color="black", style=dashed]
    node16335 [shape=diamond, label=<<font color="black">(= %1 true)</font>> color="black" fillcolor="white", style=filled]
    node16335 -> node16336 [label=<<font color="black">true</font>> color="black"]
    node16335 -> node16337 [label=<<font color="black">false</font>> color="black"]
    node16336_name [shape=none, label=<<font color="black">Block[16336]</font>>]
    node16336_name -> node16336 [arrowhead=none, color="black", style=dashed]
    node16336 [shape=box, label=<<font color="black">[0] return 0.0f<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node16336 -> cluster2405_exit [color="black"]
    node16337_name [shape=none, label=<<font color="black">Block[16337]</font>>]
    node16337_name -> node16337 [arrowhead=none, color="black", style=dashed]
    node16337 [shape=box, label=<<font color="black">[0] let length = O.ArrayLength<BR ALIGN="LEFT"/>[1] return ([number] length)<BR ALIGN="LEFT"/></font>> color="black" fillcolor="white", style=filled]
    node16337 -> cluster2405_exit [color="black"]
  }
}