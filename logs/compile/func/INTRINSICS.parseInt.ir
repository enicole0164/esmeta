def <BUILTIN>:INTRINSICS.parseInt(
  this: ESValue,
  argumentsList: List[ESValue],
  NewTarget: Object | Undefined,
): Unknown {
  if (< 0 argumentsList.length) let string = (pop < argumentsList) else let string = absent
  if (< 0 argumentsList.length) let radix = (pop < argumentsList) else let radix = absent
  call %0 = clo<ToString>(string)
  let inputString = [? %0]
  call %1 = clo<TrimString>(inputString, ~start~)
  let S = [! %1]
  let sign = 1
  (yet "If _S_ is not empty and the first code unit of _S_ is the code unit 0x002D (HYPHEN-MINUS), set _sign_ to -1.")
  (yet "If _S_ is not empty and the first code unit of _S_ is the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), remove the first code unit from _S_.")
  call %2 = clo<ToInt32>(radix)
  let R = ([math] [? %2])
  let stripPrefix = true
  if (! (== R 0)) {
    if (|| (< R 2) (< 36 R)) {
      return NaN
    } else {}
    if (! (== R 16)) {
      stripPrefix = false
    } else {}
  } else {
    R = 10
  }
  if (= stripPrefix true) {
    (yet "If the length of _S_ is at least 2 and the first two code units of _S_ are either *\"0x\"* or *\"0X\"*, then\n  1. Remove the first two code units from _S_.\n  1. Set _R_ to 16.")
  } else {}
  (yet "If _S_ contains a code unit that is not a radix-_R_ digit, let _end_ be the index within _S_ of the first such code unit; otherwise, let _end_ be the length of _S_.")
  let Z = (substring S 0 end)
  if (= Z.length 0) {
    return NaN
  } else {}
  (yet "Let _mathInt_ be the integer value that is represented by _Z_ in radix-_R_ notation, using the letters <b>A</b>-<b>Z</b> and <b>a</b>-<b>z</b> for digits with values 10 through 35. (However, if _R_ is 10 and _Z_ contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if _R_ is not 2, 4, 8, 10, 16, or 32, then _mathInt_ may be an implementation-approximated integer representing the integer value denoted by _Z_ in radix-_R_ notation.)")
  if (== mathInt 0) {
    if (== sign (- 1)) {
      return -0.0f
    } else {}
    return 0.0f
  } else {}
  return ([number] (* sign mathInt))
}