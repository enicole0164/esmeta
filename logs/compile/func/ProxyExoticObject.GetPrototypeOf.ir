def <INTERNAL>:ProxyExoticObject.GetPrototypeOf(
  O: ProxyExoticObject,
): Normal[Object | Null] | Abrupt {
  let handler = O.ProxyHandler
  if (= handler null) {
    return comp[~throw~/~empty~]((new OrdinaryObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%TypeError.prototype%"], "ErrorData" -> undefined))[#480])
  } else {}
  assert (= (typeof handler) @Object)
  let target = O.ProxyTarget
  call %0 = clo<GetMethod>(handler, "getPrototypeOf")
  let trap = [? %0]
  if (= trap undefined) {
    method-call %1 = target->GetPrototypeOf()
    return [? %1]
  } else {}
  call %2 = clo<Call>(trap, handler, (new [target])[#481])
  let handlerProto = [? %2]
  if (! (|| (= (typeof handlerProto) @Object) (= (typeof handlerProto) @Null))) {
    return comp[~throw~/~empty~]((new OrdinaryObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%TypeError.prototype%"], "ErrorData" -> undefined))[#482])
  } else {}
  call %3 = clo<IsExtensible>(target)
  let extensibleTarget = [? %3]
  if (= extensibleTarget true) {
    return handlerProto
  } else {}
  method-call %4 = target->GetPrototypeOf()
  let targetProto = [? %4]
  call %5 = clo<SameValue>(handlerProto, targetProto)
  if (= %5 false) {
    return comp[~throw~/~empty~]((new OrdinaryObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%TypeError.prototype%"], "ErrorData" -> undefined))[#483])
  } else {}
  return handlerProto
}