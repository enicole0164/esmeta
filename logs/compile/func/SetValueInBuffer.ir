def SetValueInBuffer(
  arrayBuffer: Unknown["ArrayBufferOrSharedArrayBuffer"],
  byteIndex: Unknown["NonnegativeInteger"],
  type: Unknown["TypedArrayElementType"],
  value: Number | BigInt,
  isTypedArray: Boolean,
  order: Const[~Init~, ~SeqCst~, ~Unordered~],
  isLittleEndian?: Boolean,
): Const[~unused~] {
  call %0 = clo<IsDetachedBuffer>(arrayBuffer)
  assert (= %0 false)
  assert (yet "There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.")
  assert (yet "Type(_value_) is BigInt if IsBigIntElementType(_type_) is *true*; otherwise, Type(_value_) is Number.")
  let block = arrayBuffer.ArrayBufferData
  (yet "Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.")
  if (= isLittleEndian absent) {
    (yet "set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.")
  } else {}
  call %1 = clo<NumericToRawBytes>(type, value, isLittleEndian)
  let rawBytes = %1
  call %2 = clo<IsSharedArrayBuffer>(arrayBuffer)
  if (= %2 true) {
    (yet "Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.")
    (yet "Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().")
    %3 = (= isTypedArray true)
    if %3 {
      call %4 = clo<IsNoTearConfiguration>(type, order)
      %3 = (= %4 true)
    } else {}
    if %3 {
      let noTear = true
    } else {
      let noTear = false
    }
    push eventList < (new WriteSharedMemory("Order" -> order, "NoTear" -> noTear, "Block" -> block, "ByteIndex" -> byteIndex, "ElementSize" -> elementSize, "Payload" -> rawBytes))[#1147]
  } else {
    (yet "store the individual bytes of _rawBytes_ into _block_, starting at _block_[_byteIndex_].")
  }
  return ~unused~
}