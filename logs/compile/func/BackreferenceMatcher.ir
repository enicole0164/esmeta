def BackreferenceMatcher(
  n: Unknown["PositiveInteger"],
  direction: Const[~backward~, ~forward~],
): Unknown["Matcher"] {
  assert (! (< n 1))
  (yet "Return a new Matcher with parameters (_x_, _c_) that captures _n_ and _direction_ and performs the following steps when called:\n  1. Assert: _x_ is a State.\n  1. Assert: _c_ is a Continuation.\n  1. Let _cap_ be _x_'s _captures_ List.\n  1. Let _r_ be _cap_[_n_].\n  1. If _r_ is *undefined*, return _c_(_x_).\n  1. Let _e_ be _x_'s _endIndex_.\n  1. Let _rs_ be _r_'s _startIndex_.\n  1. Let _re_ be _r_'s _endIndex_.\n  1. Let _len_ be _re_ - _rs_.\n  1. If _direction_ is ~forward~, let _f_ be _e_ + _len_.\n  1. Else, let _f_ be _e_ - _len_.\n  1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.\n  1. Let _g_ be min(_e_, _f_).\n  1. If there exists an integer _i_ between 0 (inclusive) and _len_ (exclusive) such that Canonicalize(_Input_[_rs_ + _i_]) is not the same character value as Canonicalize(_Input_[_g_ + _i_]), return ~failure~.\n  1. Let _y_ be the State (_f_, _cap_).\n  1. Return _c_(_y_).")
}