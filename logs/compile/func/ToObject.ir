def ToObject(
  argument: Unknown,
): Unknown {
  if (= (typeof argument) @Undefined) {
    return comp[~throw~/~empty~]((new OrdinaryObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%TypeError.prototype%"], "ErrorData" -> undefined))[#1371])
  } else {}
  if (= (typeof argument) @Null) {
    return comp[~throw~/~empty~]((new OrdinaryObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%TypeError.prototype%"], "ErrorData" -> undefined))[#1372])
  } else {}
  if (= (typeof argument) @Boolean) {
    return (new OrdinaryObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%Boolean.prototype%"], "BooleanData" -> argument, "Extensible" -> true))[#1373]
  } else {}
  if (= (typeof argument) @Number) {
    return (new OrdinaryObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%Number.prototype%"], "NumberData" -> argument, "Extensible" -> true))[#1374]
  } else {}
  if (= (typeof argument) @String) {
    let obj = (new StringExoticObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%String.prototype%"], "StringData" -> argument, "Extensible" -> true))[#1375]
    obj.SubMap.length = (new PropertyDescriptor("Value" -> ([number] argument.length), "Writable" -> false, "Enumerable" -> false, "Configurable" -> false))[#1376]
    return obj
  } else {}
  if (= (typeof argument) @Symbol) {
    let obj = (new OrdinaryObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%Symbol.prototype%"], "SymbolData" -> argument, "Extensible" -> true))[#1377]
    return obj
  } else {}
  if (= (typeof argument) @BigInt) {
    let obj = (new OrdinaryObject("Prototype" -> @EXECUTION_STACK[0].Realm.Intrinsics["%BigInt.prototype%"], "BigIntData" -> argument, "Extensible" -> true))[#1378]
    return obj
  } else {}
  assert (= (typeof argument) @Object)
  return argument
}