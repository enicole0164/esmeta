def <BUILTIN>:INTRINSICS.Atomics.sub(
  this: ESValue,
  argumentsList: List[ESValue],
  NewTarget: Object | Undefined,
): Unknown {
  if (< 0 argumentsList.length) let typedArray = (pop < argumentsList) else let typedArray = absent
  if (< 0 argumentsList.length) let index = (pop < argumentsList) else let index = absent
  if (< 0 argumentsList.length) let value = (pop < argumentsList) else let value = absent
  call %0 = clo<TypedArrayElementType>(typedArray)
  let type = %0
  (yet "Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.")
  (yet "Let _subtract_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:\n  1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).\n  1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).\n  1. If Type(_x_) is Number, then\n    1. Let _difference_ be Number::subtract(_x_, _y_).\n  1. Else,\n    1. Assert: Type(_x_) is BigInt.\n    1. Let _difference_ be BigInt::subtract(_x_, _y_).\n  1. Let _differenceBytes_ be NumericToRawBytes(_type_, _difference_, _isLittleEndian_).\n  1. Assert: _differenceBytes_, _xBytes_, and _yBytes_ have the same number of elements..\n  1. Return _differenceBytes_.")
  call %1 = clo<AtomicReadModifyWrite>(typedArray, index, value, subtract)
  return [? %1]
}