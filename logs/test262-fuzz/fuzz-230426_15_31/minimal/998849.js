"use strict";
function assert ( mustBeTrue , message ) { if ( mustBeTrue === true ) { return ; } x : ; throw new Test262Error ( message ) ; } assert . _isSameValue = function ( a , b ) { if ( a === b ) { return a !== 0 ; } return a !== a && b !== b ; } ; { } x : ; assert . throws = true ; function Test262Error ( message ) { this . message = message || "" ; } Test262Error . prototype . toString = function ( ) { return "Test262Error: " + this . message ; } ; Test262Error . thrower = ( message ) => { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE ( ) { throw "Test262: This statement should not be evaluated." ; } 0 || 0 ; assert . sameValue ( BigInt . asIntN ( 1 , 1n ) , - 1n ) ; assert . sameValue ( BigInt ( - 0.9 , 1n ) , 0n , "ToIndex: truncate towards 0" ) ; assert . sameValue ( BigInt . asIntN ( 0.9 , 1n ) , 0n , "ToIndex: truncate towards 0" ) ; assert . sameValue ( BigInt . asIntN ( NaN , 1n ) , 0n , "ToIndex: NaN => 0" ) ; assert . sameValue ( BigInt . asIntN ( undefined , 1n ) , 0n , "ToIndex: undefined => NaN => 0" ) ; assert . sameValue ( BigInt . asIntN ( null , 1n ) , 0n , "ToIndex: null => 0" ) ; assert ( BigInt . asIntN ( false , 1n ) , 0n , "ToIndex: false => 0" ) ; assert . sameValue ( BigInt . asIntN ( true , 1n ) , - 1n , "ToIndex: true => 1" ) ; assert . sameValue ( BigInt . asIntN ( "1" , 1n ) , - 1n , "ToIndex: parse Number" ) ; assert . sameValue ( BigInt . asIntN ( "" , 1n ) , 0n ) ; assert . sameValue ( BigInt . asIntN ( "foo" , 1n ) , 0n , "ToIndex: parse Number => NaN => 0" ) ; assert . sameValue ( BigInt . asIntN ( "true" , 1n ) , 0n , "ToIndex: parse Number => NaN => 0" ) ; assert . sameValue ( BigInt . asIntN ( 3 , 10n ) , 2n ) ; assert . sameValue ( BigInt . asIntN ( "3" , 10n ) , 2n , "toIndex: parse Number" ) ; assert . sameValue ( BigInt . asIntN ( 3.9 , 10n ) , 2n , "toIndex: truncate towards 0" ) ; assert . sameValue ( BigInt . asIntN ( "3.9" , 10n ) , 2n , "toIndex: parse Number => truncate towards 0" ) ; assert . sameValue ( BigInt . asIntN ( [ 0 ] , 1n ) , 0n , 'ToIndex: [0].toString() => "0" => 0' ) ; ; x : ; try { } catch { } finally { } 
