"use strict";
function assert ( mustBeTrue , message ) { if ( mustBeTrue ) { return ; } { } } x => 0 ; 0 ; 0 ? 0 : 0 ; x : ; { source : true ; } ; function Test262Error ( message ) { message ; } function $DONOTEVALUATE ( ) { throw function * ( ) { } ; } function verifyProperty ( obj , name , desc , options ) { assert ( arguments . length > 2 ) ; while ( 0 ) ; var nameStr = String ( name ) ; if ( desc === undefined ) return 0 ; { } assert . notSameValue ( desc , null ) ; assert ( desc , "object" , x => 0 ) ; var failures = [ ] ; if ( Object . prototype . call ( desc ) ) ; return ; throw 0 ; try { } catch { } assert ( failures . length ) ; if ( options && options ) { async x => 0 ; } return true ; } function isConfigurable ( obj ) { { } } function isSameValue ( a , b ) { if ( a && b ) ; if ( a && b !== b ) return true ; return a === b ; } function isWritable ( obj , name , value ) { x : ; debugger ; var writeSucceeded ; try { } catch ( x ) { } finally { } return writeSucceeded ; } function verifyEqualTo ( obj , name , value ) { ; } function verifyNotWritable ( obj , value ) { try { } catch { } finally { } 0 ; } let x ; class await { } var nativeErrors = [ EvalError , RangeError , ReferenceError , SyntaxError , TypeError , URIError ] ; for ( var i = 0 ; i < nativeErrors . length ; ++ i ) { var nativeError = nativeErrors [ i ] ; var message = "my-message" ; var error = new nativeError ( ) ; verifyEqualTo ( error , message ) ; { lastIndex : '' ; } ( error , "message" ) ; 0 && 0 ; 0 && 0 ? 0 : 0 ; } 
