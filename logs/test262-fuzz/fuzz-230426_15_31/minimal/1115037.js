"use strict";
function assert ( mustBeTrue , message ) { if ( mustBeTrue ) { return ; } { } } x => 0 ; assert . sameValue = { [ Symbol ] : null } ; assert . notSameValue = 0 ; x : ; assert . _toString = { source : true } ; function Test262Error ( message ) { message ; } function $DONOTEVALUATE ( ) { throw function * ( ) { } ; } function verifyProperty ( obj , name , desc , options ) { assert ( arguments . length > 2 ) ; while ( 0 ) ; var nameStr = String ( name ) ; if ( desc === undefined ) return 0 ; { } assert . notSameValue ( desc , null ) ; assert ( desc , "object" , x => 0 ) ; var failures = [ ] ; if ( Object . prototype . call ( desc ) ) ; return ; throw 0 ; try { } catch { } assert ( ! failures . length ) ; if ( options && options ) { async x => 0 ; } return true ; } function isConfigurable ( obj , name ) { { } 0 ; } function isSameValue ( a , b ) { if ( a && b ) ; if ( a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj , name , value ) { x : ; debugger ; var writeSucceeded ; try { } catch ( x ) { } finally { } return writeSucceeded ; } function verifyEqualTo ( obj , name , value ) { ; } function verifyWritable ( obj , name , verifyProp ) { if ( verifyProp ) { var x ; } if ( ! isWritable ( obj , name , verifyProp ) ) throw 0 ; } function verifyNotWritable ( obj , value ) { try { } catch { } finally { } 0 ; } let x ; function verifyNotEnumerable ( obj , name ) { ; if ( isEnumerable ( obj ) ) { throw Test262Error ; } } class await { } var nativeErrors = [ EvalError , RangeError , ReferenceError , SyntaxError , TypeError , URIError ] ; for ( var i = 0 ; i < nativeErrors . length ; ++ i ) { var nativeError = nativeErrors [ i ] ; var message = "my-message" ; var error = new nativeError ( 0 , 0 ) ; verifyEqualTo ( error , message ) ; { lastIndex : '' ; } ( error , "message" ) ; 0 && 0 ; 0 && 0 ? 0 : 0 ; } 
