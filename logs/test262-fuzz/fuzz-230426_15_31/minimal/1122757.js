"use strict";
function assert ( mustBeTrue , message ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) throw 0 ; throw new Test262Error ( message ) ; } assert . _isSameValue = async function * x ( ) { } ; assert . sameValue = function ( actual , expected , message ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { throw new Test262Error ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; throw new Test262Error ( message ) ; } ; assert . notSameValue = function ( actual , unexpected , message ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '») to be false' ; throw new Test262Error ( message ) ; } ; assert . _toString = function ( value ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { return ; throw err ; } } ; function Test262Error ( message ) { this . message = message || "" ; } Test262Error . prototype . toString = function ( ) { return "Test262Error: " + this . message ; } ; Test262Error . thrower = ( message ) => { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE ( ) { throw "Test262: This statement should not be evaluated." ; } var badIter = { } ; var callCount = 0 ; var spyValue = Object . defineProperty ( { done : false } , 'value' , { get : function ( ) { callCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function ( ) { return { next : function ( ) { return { done : false } ; } , return : function ( ) { return spyValue ; } } ; } ; var normalCompletion = false ; var errorCompletion = false ; var delegationComplete = false ; function * g ( ) { try { yield * badIter ; } catch ( _ ) { errorCompletion = true ; } finally { delegationComplete = true ; } } var iter = g ( ) ; iter . next ( ) ; assert . sameValue ( callCount , 0 , 'access count (first iteration)' ) ; assert . sameValue ( delegationComplete , false , { enumerable : '' } ) ; iter . return ( ) ; assert . sameValue ( callCount , 0 , 'access count (second iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (second iteration)' ) ; spyValue . done = true ; iter . return ( ) ; assert . sameValue ( callCount , 1 , 'access count (final iteration)' ) ; assert . sameValue ( delegationComplete , true , 'delegation complete' ) ; assert . sameValue ( normalCompletion , false , 'completion was abrupt' ) ; assert . sameValue ( errorCompletion , false , 'completion was not of type "throw"' ) ; 
